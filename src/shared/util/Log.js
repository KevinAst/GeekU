'use strict'

import pad    from 'pad';
import moment from 'moment';

/**
 * Log is a JavaScript logging utility that promotes filterable
 * logging probes, similar in nature to Log4J.  
 *
 * All logging is based on functional callbacks, which means there is
 * virtually NO overhead in leaving debugging level logging probes in
 * production code (because any overhead in constructing a message is
 * ONLY incurred when the message will in fact be logged).  With the
 * advent of ES6 arrow functions, this callback function is very much
 * streamlined:
 *
 *  log.debug(()=>`some complex stream with bunches of ${overhead}`);
 *
 * Log is isomorphic JavaScript, meaning it operates BOTH in
 * browser/node.
 *
 * ??? more doc here, including
 *     - ?? filters
 *     - ?? usage
 *     - ?? configuration
 *
 * @author Kevin Bridges
 */
class Log {

  /**
   * Construct a new Log instance.
   * 
   * @param {String} filterName the probe identifier defined within this
   * log instance, used in the Log filters.  This filterName can be re-used
   * crossing JS module boundaries.
   * 
   * @api public
   */
  constructor(filterName) {

    if (!filterName) {
      throw new Error('Log() contructor requires a filterName.');
    }

    // retain filterName in self
    this.filterName = filterName;

    // inject filterName in the Log filter
    // ... simply share existing filters (found in different Log
    //     instances [typically in different JS modules])
    if (!Log.filter[filterName]) {
      Log.filter[filterName] =  Log.DEFAULT_FILTER_LEVEL;
    }
  }

  /**
   * Various logging shortcut methods, machine generated by
   * registerLevel(levelName, level).
   * 
   * EXAMPLE: debug(txtFn)
   *
   * @param {int} level the log level for this probe (e.g. Log.DEBUG).
   * 
   * @api public
   */
  // example (machine generated) ...
//debug(txtFn) {
//  this.log(Log.DEBUG, txtFn);
//}

  /**
   * Conditionally log a message, when enabled within our filter.
   *
   * @param {int} level the log level for this probe (e.g. Log.DEBUG).
   * @param {function} txtFn a callback function returning the txt string to log. 
   * 
   * @api public
   */
  log(level, txtFn) {
    // validate params
    const levelName = Log.levelName[level];
    if (!levelName) {
      throw new Error(`Invalid log level: ${level}`);
    }
    if (typeof txtFn !== 'function') {
      throw new Error(`Log.log: expecting txtFn param to be a function, but is a: ${typeof txtFn}`);
    }

    // conditionally log this message when enabled within our filter
    if ( this.isEnabled(level, this.filterName) ) {
      console.log( Log.formatLog(this, levelName, txtFn) );
    }
  }

  /**
   * Is the supplied level enabled in Log's filter (defined by self's filterName).
   *
   * @param {int} level the log level for this probe (e.g. Log.DEBUG).

   * @return {boolean}
   * 
   * @api public ... however only needed in rare conditions
   */
  isEnabled(level) {
    const filterLevel = Log.filter[this.filterName];
    return filterLevel <= level;
  }


  // *** 
  // *** Configuration Related ...
  // *** 

  /**
   * Register a logging level.  This method is typically invoked
   * internally to establish the standard base levels, however
   * additional levels can be registered.
   *
   * @param {String} levelName the level name (e.g. DEBUG, WARN, etc)
   * @param {int} level the cooresponding numeric log level.  The
   * greater the level the more severe (e.g. ERROR of 500 is more
   * severe than INFO of 300).
   *
   * @api public
   */
  static registerLevel(levelName, level) {
    const levelNameUpper = levelName.toUpperCase();
    Log[levelNameUpper]  = level;
    Log.levelName[level] = levelNameUpper;

    const levelNameLower = levelName.toLowerCase();
    Log.prototype[levelNameLower] = function(txtFn) {
      this.log(Log[levelNameUpper], txtFn);
    };
  }

  /**
   * Configure the Log filter by applying the settings of the supplied filter.
   *
   * @param {Object} filter the filter to apply ... ex: 
   * {'Initialization': Log.DEBUG, 'Foo Service': Log.TRACE}
   *
   * @api public (configuration related)
   */
  static applyFilter(filter) {
    Object.assign(Log.filter, filter);
    // TODO: validate filter content of string/int
    // ? Log.filter = {
    // ?   'Initialization': 200,
    // ?   'Foo Service':    400
    // ? };
  }

}


/**
 * Log Level defined constants - programmatically set via Log.registerLevel()
 * @api public
 */
// ex ...
// Log.DEBUG = 200;

/**
 * Log Level names - programmatically set via Log.registerLevel()
 * @api private
 */
Log.levelName = {
  // ex ...
  // 200: 'DEBUG'
};

/**
 * Log filter - programmatically set via Log() constructor
 * @api private
 */
Log.filter = {
  // ex ...
  // 'Initialization': 200
  // 'Foo Service':    400
};

/**
 * Format the log entry to emit.
 * @api private (however can be re-set in initial Log configuration)
 */
Log.formatLog = function(log, levelName, txtFn) {
  return `
${pad(levelName, 5)} ${moment().format('YYYY-MM-DD HH:mm:ss')} (${log.filterName}):
      ${txtFn()}`;
};


/**
 * Default Filter Level, for initial filter registration.
 * @api private (however can be re-set in initial Log configuration)
 */
Log.DEFAULT_FILTER_LEVEL = Log.INFO;


// register our initial standard base levels
Log.registerLevel('OFF',   999);
Log.registerLevel('FATAL', 600);
Log.registerLevel('ERROR', 500);
Log.registerLevel('WARN',  400);
Log.registerLevel('INFO',  300);
Log.registerLevel('DEBUG', 200);
Log.registerLevel('TRACE', 100);


export default Log
