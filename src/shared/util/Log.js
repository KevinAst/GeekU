'use strict'

import assert     from 'assert';
import pad        from 'pad';
import moment     from 'moment';
import shortid    from 'shortid';
import HTTPStatus from 'http-status';

/**
 * Log is a lightweight JavaScript logging utility that promotes
 * filterable logging probes, similar to a number of frameworks such
 * as Log4J.
 *
 * By default, Log is a thin layer on top of console.log(), simply 
 * adding filters.
 *
 * Log is an isomorphic JavaScript utility (i.e. will operate BOTH
 * in browser/node environments.
 * 
 * Log is fully documented in Log.md.
 *
 * @author Kevin Bridges
 */
class Log {

  /**
   * Construct a new Log instance.
   * 
   * @param {String} filterName the probe identifier defined within this
   * log instance, used in the Log filters.  This filterName can be re-used
   * crossing JS module boundaries.
   * 
   * @api public
   */
  constructor(filterName) {

    assert(filterName, 'Log() contructor requires a filterName.');

    // ??? enhance to support filter hierarchies (with last resort to pre-defined 'root')

    // retain filterName in self
    this.filterName = filterName;

    // inject filterName in the Log filter
    // ... simply share existing filters (found in different Log
    //     instances [typically in different JS modules])
    if (!Log.filter[filterName]) {
      Log.filter[filterName] =  Log.DEFAULT_FILTER_LEVEL;
    }
  }


//   SAMPLE: machine generated by Log.registerLevel(levelName, level)
///**
// * A level-specific log() convenience method, implying a Log.DEBUG 
// * level in the method name.
// *
// * @param {function} msgFn a callback function emitting the msg string to log. 
// * @param {Object} obj an optional object (or Error) to detail in the logging probe.
// * 
// * @api public
// */
// debug(msgFn, obj) {
//   this.log(Log.DEBUG, msgFn, obj);
// }


  /**
   * Conditionally emit a message probe in our log, when enabled within our filter.
   *
   * @param {int} level the log level for this probe (e.g. Log.DEBUG).
   * @param {function} msgFn a callback function emitting the msg string to log. 
   * @param {Object} obj an optional object (or Error) to detail in the logging probe.
   * 
   * @api public
   */
  log(level, msgFn, obj) {
    // validate params ... TODO: may want to turn validation off for performance
    const levelName = Log.levelName[level];
    assert(levelName, `Log.log(...) ERROR: Invalid log level: ${level}`);
    assert(typeof msgFn === 'function', `Log.log(...) ERROR: Supplied msgFn was NOT a function, rather  a ${typeof msgFn} type`);

    // conditionally log this message when enabled within our filter
    if ( this.isLevelEnabled(level, obj) ) {
      console.log( Log.formatMsg(this.filterName, levelName, msgFn, obj) );
    }
  }


//   SAMPLE: machine generated by Log.registerLevel(levelName, level)
///**
// * A level-specific isLevelEnabled() convenience method, implying a Log.DEBUG 
// * level in the method name.
// *
// * @param {Object} obj an optional object that for Error instances,
// * can veto the enablement.
// *
// * @return {boolean}
// * 
// * @api public
// */
//isDebugEnabled(obj) {
//  this.isLevelEnabled(Log.DEBUG, obj);
//}


  /**
   * Return an indicator as to whether the supplied level
   * is enabled by our filter.
   *
   * @param {int} level the log level for this probe (e.g. Log.DEBUG).
   * @param {Object} obj an optional object that for Error instances,
   * can veto the enablement.
   *
   * @return {boolean}
   * 
   * @api public
   */
  isLevelEnabled(level, obj) {
    // ??? enhance to support filter hierarchies (with last resort to pre-defined 'root')
    const filterLevel = Log.filter[this.filterName];
    let   enabled     = filterLevel <= level;

    // allow supplied Error object to veto the probe emission
    if (enabled &&                // we are preliminary enabled (as far as our filter is concerned)
        Log.allowErrorToVetoProbeEmission && // our configuation allows Errors to veto the probe emission
        obj &&                    // obj has been supplied
        obj instanceof Error) {   // that is an Error
      const err = obj;

      // no logging is required when ...
      if (err.cause === Error.Cause.RECOGNIZED_CLIENT_ERROR || // the err is a recognized client condition, or
          err.logId) {                                         // the err has already been logged
        enabled = false;
      }
          
    }
        
    // that's all folks :-)
    return enabled;
  }




  // *** 
  // *** Configuration Related ...
  // *** 

  /**
   * Configure the Log filter by applying the settings of the supplied filter.
   *
   * @param {Object} filter the filter to apply ... ex: 
   * {'Initialization': Log.DEBUG, 'Foo Service': Log.TRACE}
   *
   * @api public
   */
  static applyFilter(filter) {
    // ??? revamp, tappinging into new structure, and validate filter content of string/int
    // ? Log.filter = {
    // ?   'Initialization': 200,
    // ?   'Foo Service':    400
    // ? };
    Object.assign(Log.filter, filter);
  }


  /**
   * Register a logging level.  This method is typically invoked
   * internally to establish the standard base levels, however any
   * number of additional levels can be registered by the Log client.
   *
   * @param {String} levelName the level name (e.g. DEBUG, WARN, etc)
   * @param {int} level the cooresponding numeric log level.  The
   * greater the level the more severe (e.g. ERROR of 500 is more
   * severe than INFO of 300).
   *
   * @api public
   */
  static registerLevel(levelName, level) {

    // inject static Log constants, for example:
    //   Log.DEBUG          = 200;
    //   Log.levelName[200] = 'DEBUG';
    const levelNameUpper = levelName.toUpperCase();
    Log[levelNameUpper]  = level;
    Log.levelName[level] = levelNameUpper;

    // inject level-specific log() convenience method, for example:
    //   log.debug(msgFn, obj); ... alias to log.log(LEVEL, txFn, obj)
    const levelNameLower = levelName.toLowerCase();
    Log.prototype[levelNameLower] = function(msgFn, obj) {
      this.log(Log[levelNameUpper], msgFn, obj);
    };

    // inject level-specific isLevelEnabled() convenience method, for example:
    //   log.isDebugEnabled(obj); ... alias to log.isEnabled(LEVEL, obj) ?? test needed
    const levelNameHumpback = levelNameLower.charAt(0).toUpperCase() + levelNameLower.slice(1);
    Log.prototype[levelNameHumpback] = function(obj) {
      this.isLevelEnabled(Log[levelNameUpper], obj);
    };
  }





  // *** 
  // *** Utility Related ...
  // *** 

  /**
   * Format the log entry to emit.
   *
   * @param {String} filterName the log filter-name for this probe (e.g. 'appStartup').
   * @param {String} levelName the log level-name for this probe (e.g. 'DEBUG').
   * @param {function} msgFn a callback function emitting the msg string to log.
   * @param {Object} obj an optional object (or Error) to detail in the logging probe.
   *
   * @return {String} the formatted message to log
   *
   * @api private (however can be re-set in initial Log configuration)
   */
  static formatMsg(filterName, levelName, msgFn, obj) {
    return `
${pad(levelName, 5)} ${moment().format('YYYY-MM-DD HH:mm:ss')} ${filterName}${Log.extra()}:
      ${msgFn()}${Log.formatObj(obj)}`;
  };

  // ?? temp for now
  static extra() {
    return '';
  };


  /**
   * Format the supplied object (when defined).
   *
   * @param {Object} obj an optional object (or Error) to detail in the logging probe.
   *
   * @return {String} a formatted representation of the supplied obj (empty string [''] when not supplied.
   *
   * @api private (however can be re-set in initial Log configuration)
   */
  static formatObj(obj) {

    if (!obj) {
      return '';
    }

    // Errors are special
    if (obj instanceof Error) {
      return Log.formatError(obj);
    }

    // Date objects don't format much in subsequent Object algorithm
    if (typeof obj.getMonth === 'function') {
      return `
      Date: ${obj}`;
    }

    // Object catch-all
    let objStr = `
      Object:`;
    if (obj) {
      for (let prop in obj) {
        const val = typeof(obj[prop]) === 'function' ? 'function' : obj[prop];
        objStr += `\n        ${prop}: ${val}`;
      }
    }
    return objStr;
  }


  /**
   * Format the supplied error object.
   *
   * @param {Error} err the error object to detail in the logging probe.
   *
   * @return {String} a formatted representation of the supplied error.
   *
   * @api private (however can be re-set in initial Log configuration)
   */
  static formatError(err) {

    // define a logId for this Error
    err.logId = shortid.generate();
    
    // return our formatted representation of the err
    let msg =  `
      Error:
        Name:       ${err.name}`;
    if (err.httpStatus)
      msg += `
        Status:     ${err.httpStatus}
        StatusMsg:  ${HTTPStatus[err.httpStatus]}`;
    msg += `
        Client Msg: ${err.clientMsg}
        Message:    ${err.message}`;
    if (err.url)
      msg += `
        URL:        ${err.url}`;
    msg += `
        LogId:      ${err.logId}
        Stack Trace:
         ${err.stack}
`;
    return msg;
  }

} // end of ... class Log


/**
 * Log Level defined constants - programmatically set via Log.registerLevel()
 * @api public
 */
// ex ...
// Log.DEBUG = 200;

/**
 * Log Level names - programmatically set via Log.registerLevel()
 * @api private
 */
Log.levelName = {
  // ex ...
  // 200: 'DEBUG'
};

/**
 * Log filter - programmatically set via Log() constructor
 * @api private
 */
Log.filter = {
  // ex ...
  // 'Initialization': 200
  // 'Foo Service':    400
};

/**
 * Configuration that allows Error objects to veto the probe emission
 * @api private
 */
Log.allowErrorToVetoProbeEmission = false; // ?? temp should be true


// register our initial standard base levels
Log.registerLevel('TRACE', 100);
Log.registerLevel('DEBUG', 200);
Log.registerLevel('INFO',  300);
Log.registerLevel('WARN',  400);
Log.registerLevel('ERROR', 500);
Log.registerLevel('FATAL', 600);
Log.registerLevel('OFF',   999);

/**
 * Default Filter Level, for initial filter registration.
 * NOTE: Declaration MUST be AFTER Log.INFO is defined (via Log.registerLevel('INFO',...)
 * @api private (however can be re-set in initial Log configuration)
 */
// TODO: eliminate DEFAULT_FILTER_LEVEL in favor of a run-time reference to pre-defined 'root' filter
Log.DEFAULT_FILTER_LEVEL = Log.INFO;


export default Log
